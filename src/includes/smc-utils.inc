IF !DEF(SMC_UTILS_INC)
SMC_UTILS_INC = 1

; operations
NO_OP_OP EQU $00 ; no oppish!
CALL_OP EQU $CD ; remember, low then high!
RET_OP EQU $C9
LD_A_N8 EQU $3E ; for loading tiles into a
LD_N16_A EQU $EA ; for loading a into VRAM

LD_A_N16 EQU $FA ; unused

; ld a, n8 ; 2 bytes
; ld [n16], a ; 3 bytes
TEMPLATE_SLOT EQU 5 ; 5 bytes per slot
START_TEMPLATE EQU 1 ; ret/nop at the start
END_TEMPLATE EQU 1 ; ret at the end

SECTION "TemplateUtilites", ROM0

VRAM_ADDRESS EQU 0
TILE_DATA EQU 0

/*
VBLANK is 10 lines
each line 456 dots
each 4 dots to the M-cycle
so 10 * (456 / 4) = 1140 M-cycles per vblank

VRAMTemplate is 6 cycles per tile
so 1140 / 6 = 190
4 tiles per meta-tile
190 / 4 = 47.5 meta-tiles or roughly 4 rows!?

ALSO 190 / 20 = 9.5 rows of tiles... there are only 18 rows
so we can completely redraw the screen every 2 frames and
get 30 fps BUT we need 5 bytes per slot so 18 * 20 * 5 = 1800 bytes

we can statically create the template with the VRAM addresses hardcoded
so we only need to write 1 byte then advance 4

We have 144 lines between VBLANKS which is
144 * (456 / 4) = 16416 M-Cycles
fillTileSlot is 12 cycles and we need to do it 190 times so 2,280 cycles
of course also need to read the map to find the right tiles

OK OR we can make a 190 tile section of the screen be the "viewport"
and update it in one go ... 47 metatiles

*/

/*
@param b - number of tiles
@param hl - address at which to create the template */
makeVRAMTemplate:
  ld a, RET_OP
  ld [hl+], a

; ld a, n8 ; 2 bytes, 2 cycles
; ld [n16], a ; 3 bytes, 4 cycles
.loop
  ld a, LD_A_N8
  ld [hl+], a
  ld a, TILE_DATA
  ld [hl+], a
  ld a, LD_N16_A
  ld [hl+], a
  ld a, VRAM_ADDRESS ; low byte
  ld [hl+], a
  ld a, VRAM_ADDRESS ; high byte
  ld [hl+], a

  dec b
  jr nz, .loop

  ld a, RET_OP
  ld [hl+], a

  ret


ENDC	; end definition of SMC utils file